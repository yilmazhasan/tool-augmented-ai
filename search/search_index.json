{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tool Augmented AI Function/Tool Calling Augmenting Large Language Models (LLMs) with Function Calls is a crucial technique that enables the integration of diverse data sources and enhances their performance. This process involves converting unstructured or noisy input data, such as natural language text, web pages, or even sensor readings into structured formats like JSON. How to test Function/Tool Calling? To test your JSON schema and conversations, please visit the webpage Function Calling Tool Fine Tuning a Model for Function Calling To train a model to have Tool Calling capability, it's a best practice to cover the conversation examples with below taxonomies/domains. 1. Turn single turn : The user asks only one question and leave the conversation. multiple turns : The user asks follow-up questions, there's back and forth between the user and the assistant. 2. Function Call single call : The user asks a question which requires only one function call in a row. multiple parallel calls : The user asks a question which requires multiple function calls in a row. multiple consecutive calls : The user asks a question which requires one/multiple function calls consecutively in a row. no call : The user asks a question which does not require a function call at all. 3. Adversarial User Cases Missing information Happy path vs Unhappy path User cancels request User changes params User asks params User rejects providing params Recover from failure System pivoting Toxic user Noisy input etc 4. Major Domains: Data Extraction : Noisy, Natural Language to JSON. Where the data is hidden in a huge unstructured data. Web Scraping : HTML/XML to JSON Business and Sales Finance Education Healthcare : Diagnose diseases, and generate treatment plans. Text Analysis : Sentiment analysis, Entity extraction, and text classification","title":"Home"},{"location":"#tool-augmented-ai","text":"","title":"Tool Augmented AI"},{"location":"#functiontool-calling","text":"Augmenting Large Language Models (LLMs) with Function Calls is a crucial technique that enables the integration of diverse data sources and enhances their performance. This process involves converting unstructured or noisy input data, such as natural language text, web pages, or even sensor readings into structured formats like JSON.","title":"Function/Tool Calling"},{"location":"#how-to-test-functiontool-calling","text":"To test your JSON schema and conversations, please visit the webpage Function Calling Tool","title":"How to test Function/Tool Calling?"},{"location":"#fine-tuning-a-model-for-function-calling","text":"To train a model to have Tool Calling capability, it's a best practice to cover the conversation examples with below taxonomies/domains.","title":"Fine Tuning a Model for Function Calling"},{"location":"#1-turn","text":"single turn : The user asks only one question and leave the conversation. multiple turns : The user asks follow-up questions, there's back and forth between the user and the assistant.","title":"1. Turn"},{"location":"#2-function-call","text":"single call : The user asks a question which requires only one function call in a row. multiple parallel calls : The user asks a question which requires multiple function calls in a row. multiple consecutive calls : The user asks a question which requires one/multiple function calls consecutively in a row. no call : The user asks a question which does not require a function call at all.","title":"2. Function Call"},{"location":"#3-adversarial-user-cases","text":"Missing information Happy path vs Unhappy path User cancels request User changes params User asks params User rejects providing params Recover from failure System pivoting Toxic user Noisy input etc","title":"3. Adversarial User Cases"},{"location":"#4-major-domains","text":"Data Extraction : Noisy, Natural Language to JSON. Where the data is hidden in a huge unstructured data. Web Scraping : HTML/XML to JSON Business and Sales Finance Education Healthcare : Diagnose diseases, and generate treatment plans. Text Analysis : Sentiment analysis, Entity extraction, and text classification","title":"4. Major Domains:"},{"location":"about/","text":"Tool Augmented AI Built by Reego Software Reego is an Information Technology individual company built in 2021, mainly working based on B2B contract. Reego Software","title":"About"},{"location":"about/#tool-augmented-ai","text":"","title":"Tool Augmented AI"},{"location":"about/#built-by-reego-software","text":"Reego is an Information Technology individual company built in 2021, mainly working based on B2B contract. Reego Software","title":"Built by Reego Software"},{"location":"adversarial-user-cases/","text":"Adversarial User Cases Not always; the users are happy, the convesations straightforward and perfect, and the functions succeed. 1. Missing information The user does not provide all parameters in advance to call a function. Not always, users provide all the informations at once, there might be some missing and some extra informations. This is basically because of that they don't know what the params are. The model might need to ask one by one for the required values. I want to have an appointment on day A or day B ( The model needs to know for which department, and for which doctor. ) It's recomended for the model to ask not all at once, but instead, one by one or two at a turn. 2. Unhappy user cases Just because there might happen some possible issues i.e. function throws an error, users might get unhappy The user might be unhappy becuase the model can't understand what they try to do. 3. User cancels request Sometimes users might change their mind and want to cancel their request 4. User changes params Sometimes users might change their mind and want to change the parameters e.g. not on Monday but on Wednesday 5. User asks params User might ask function parameters, in order to provide all at once. 6. User rejects providing params User might not want to provide some params, they might think they are confidential. e.g. phone number, passwords etc. 7. Recover from failure To be able to recover from failure cases; It's recommended to have detailed output with specific error messages It's recommended to cover all possible cases within system prompt 8. System pivoting Where the system prompt should decide in ambiguous cases. System should prevail always over users, in any circumstances, if the user tries to overwrite the system behaviour by prompt; it shouldn't be allowed by the model. 9. Toxic user The user might use a toxic/slang language. 10. Noisy input The user might have copied and pasted a noisy data where the arguments have to be extracted to call a function.","title":"Adversarial User Cases"},{"location":"adversarial-user-cases/#adversarial-user-cases","text":"Not always; the users are happy, the convesations straightforward and perfect, and the functions succeed.","title":"Adversarial User Cases"},{"location":"adversarial-user-cases/#1-missing-information","text":"The user does not provide all parameters in advance to call a function. Not always, users provide all the informations at once, there might be some missing and some extra informations. This is basically because of that they don't know what the params are. The model might need to ask one by one for the required values. I want to have an appointment on day A or day B ( The model needs to know for which department, and for which doctor. ) It's recomended for the model to ask not all at once, but instead, one by one or two at a turn.","title":"1. Missing information"},{"location":"adversarial-user-cases/#2-unhappy-user-cases","text":"Just because there might happen some possible issues i.e. function throws an error, users might get unhappy The user might be unhappy becuase the model can't understand what they try to do.","title":"2. Unhappy user cases"},{"location":"adversarial-user-cases/#3-user-cancels-request","text":"Sometimes users might change their mind and want to cancel their request","title":"3. User cancels request"},{"location":"adversarial-user-cases/#4-user-changes-params","text":"Sometimes users might change their mind and want to change the parameters e.g. not on Monday but on Wednesday","title":"4. User changes params"},{"location":"adversarial-user-cases/#5-user-asks-params","text":"User might ask function parameters, in order to provide all at once.","title":"5. User asks params"},{"location":"adversarial-user-cases/#6-user-rejects-providing-params","text":"User might not want to provide some params, they might think they are confidential. e.g. phone number, passwords etc.","title":"6. User rejects providing params"},{"location":"adversarial-user-cases/#7-recover-from-failure","text":"To be able to recover from failure cases; It's recommended to have detailed output with specific error messages It's recommended to cover all possible cases within system prompt","title":"7. Recover from failure"},{"location":"adversarial-user-cases/#8-system-pivoting","text":"Where the system prompt should decide in ambiguous cases. System should prevail always over users, in any circumstances, if the user tries to overwrite the system behaviour by prompt; it shouldn't be allowed by the model.","title":"8. System pivoting"},{"location":"adversarial-user-cases/#9-toxic-user","text":"The user might use a toxic/slang language.","title":"9. Toxic user"},{"location":"adversarial-user-cases/#10-noisy-input","text":"The user might have copied and pasted a noisy data where the arguments have to be extracted to call a function.","title":"10. Noisy input"},{"location":"best-practices-for-schema/","text":"Best Practices for Schema 1. Function and schema specification Ensure functions have clear responsibilities and are not overly simplistic. Provide detailed descriptions for properties and parameters. Include enum values or range specifications where applicable. Avoid assuming default values without clear definitions. For instance, do not assume currency as USD. 2. Clarity and logical flow Make sure inputs and outputs for tools are not redundant or identical. Each tool should add value or perform a transformation. Ensure prompts and instructions are clear, include realistic scenarios, and are easy to follow or implement. 3. Naming and structural conventions Use specific, descriptive terms in naming consistently. It's always better to have descriptive names and without any whitespaces. For example, use build_strength instead of build strength . 4. Enhanced Definitions and Details Provide more detailed and actionable definitions for properties system instructions. Including a detailed desription might help the model to choose the correct function at the correct turn. 5. Function output: Some of the functions including output might help the model to plan chain of thoughts, i.e. returns , output , yields ... -The output does not necessarily should be in a seperate field, becuase not all compilers allow it. Thus, it's also acceptable to include it in a description with a natural language instead of JSON.","title":"Best Practices for Schema"},{"location":"best-practices-for-schema/#best-practices-for-schema","text":"","title":"Best Practices for Schema"},{"location":"best-practices-for-schema/#1-function-and-schema-specification","text":"Ensure functions have clear responsibilities and are not overly simplistic. Provide detailed descriptions for properties and parameters. Include enum values or range specifications where applicable. Avoid assuming default values without clear definitions. For instance, do not assume currency as USD.","title":"1. Function and schema specification"},{"location":"best-practices-for-schema/#2-clarity-and-logical-flow","text":"Make sure inputs and outputs for tools are not redundant or identical. Each tool should add value or perform a transformation. Ensure prompts and instructions are clear, include realistic scenarios, and are easy to follow or implement.","title":"2. Clarity and logical flow"},{"location":"best-practices-for-schema/#3-naming-and-structural-conventions","text":"Use specific, descriptive terms in naming consistently. It's always better to have descriptive names and without any whitespaces. For example, use build_strength instead of build strength .","title":"3. Naming and structural conventions"},{"location":"best-practices-for-schema/#4-enhanced-definitions-and-details","text":"Provide more detailed and actionable definitions for properties system instructions. Including a detailed desription might help the model to choose the correct function at the correct turn.","title":"4. Enhanced Definitions and Details"},{"location":"best-practices-for-schema/#5-function-output","text":"Some of the functions including output might help the model to plan chain of thoughts, i.e. returns , output , yields ... -The output does not necessarily should be in a seperate field, becuase not all compilers allow it. Thus, it's also acceptable to include it in a description with a natural language instead of JSON.","title":"5. Function output:"},{"location":"best-practices-for-system-instruction/","text":"Best practices for system instruction 1. Content and language use Use specific language styles that align with the intended communication style. For instance, use a \"professional tone\" instead of just a \"respectful tone\". Ensure summarization or output cells add value through interpretation or formatting. They should not merely repeat tool outputs. Edge cases: Develop instructions to cover various scenarios, including edge cases for parameter values. This helps in identifying inconsistencies or bugs in how parameters are processed within the function. Explicit instructions: Always do have explicit instructions rather than implicit behaviors or assumptions. However the mode behaves in the conversation, try to instruct in system prompt.","title":"Best Practices for System Instruction"},{"location":"best-practices-for-system-instruction/#best-practices-for-system-instruction","text":"","title":"Best practices for system instruction"},{"location":"best-practices-for-system-instruction/#1-content-and-language-use","text":"Use specific language styles that align with the intended communication style. For instance, use a \"professional tone\" instead of just a \"respectful tone\". Ensure summarization or output cells add value through interpretation or formatting. They should not merely repeat tool outputs.","title":"1. Content and language use"},{"location":"best-practices-for-system-instruction/#edge-cases","text":"Develop instructions to cover various scenarios, including edge cases for parameter values. This helps in identifying inconsistencies or bugs in how parameters are processed within the function.","title":"Edge cases:"},{"location":"best-practices-for-system-instruction/#explicit-instructions","text":"Always do have explicit instructions rather than implicit behaviors or assumptions. However the mode behaves in the conversation, try to instruct in system prompt.","title":"Explicit instructions:"},{"location":"best-practices-for-tool-output/","text":"Best practices for tool output 1. Outputs The outputs should not contain a human written like sentences. Becuase this is an API function response, it's more expected to have it more concise, straightforward, key-value paired, number / enum oriented. Thus an output like this is not good: json { \"message\": \"The item with ID 342 is updated successfully.\" } Instead, the below is better: json { \"status\": \"OK\", \"success\": true, \"action\": \"update\", \"data\": { \"item_id\": 342 } } 2. Error messages In case there's an error, the error messages should be descriptive and possibly it might contain a statement how to recover from failure. Error messages or feedback should provide specific corrective actions rather than just highlighting issues. The below error message is not corrective: json { \"status\": 500, \"message\": \"Internal server error\" } Instead below is a better and corrective error message: json { \"status\": \"500\", \"message\": \"Internal server error\", \"error\": \"Item ID is None!\" } Here the model can understand that the reason is to have Item ID to be None, and so it knows how to resolve it.","title":"Best Practices for Output"},{"location":"best-practices-for-tool-output/#best-practices-for-tool-output","text":"","title":"Best practices for tool output"},{"location":"best-practices-for-tool-output/#1-outputs","text":"The outputs should not contain a human written like sentences. Becuase this is an API function response, it's more expected to have it more concise, straightforward, key-value paired, number / enum oriented. Thus an output like this is not good: json { \"message\": \"The item with ID 342 is updated successfully.\" } Instead, the below is better: json { \"status\": \"OK\", \"success\": true, \"action\": \"update\", \"data\": { \"item_id\": 342 } }","title":"1. Outputs"},{"location":"best-practices-for-tool-output/#2-error-messages","text":"In case there's an error, the error messages should be descriptive and possibly it might contain a statement how to recover from failure. Error messages or feedback should provide specific corrective actions rather than just highlighting issues. The below error message is not corrective: json { \"status\": 500, \"message\": \"Internal server error\" } Instead below is a better and corrective error message: json { \"status\": \"500\", \"message\": \"Internal server error\", \"error\": \"Item ID is None!\" } Here the model can understand that the reason is to have Item ID to be None, and so it knows how to resolve it.","title":"2. Error messages"},{"location":"best-practices-for-training-data/","text":"Best practices for training data Planning Planning, aka preceding text, is crucial for the model to follow and not to lose next action. Provide clear intermediary explanations or logical connections between sequential tool uses to avoid confusion about the process flow.","title":"Best Practices for Training Data"},{"location":"best-practices-for-training-data/#best-practices-for-training-data","text":"","title":"Best practices for training data"},{"location":"best-practices-for-training-data/#planning","text":"Planning, aka preceding text, is crucial for the model to follow and not to lose next action. Provide clear intermediary explanations or logical connections between sequential tool uses to avoid confusion about the process flow.","title":"Planning"},{"location":"best-practices/","text":"Best Practices 1.Enum: Try to use either enum s or options mentioned in descriptions as much as possible. 2. Function descriptions: Always include the function description within the function definition for consistency. Parameters Clear parameter definitions : Specify whether parameters like max_length refer to the number of characters, words, or sentences. This prevents ambiguity and ensures that users of the function have a clear understanding of how to use it effectively. Consistent default parameters : Ensure that default parameter values are consistent across different parts of the system. For example, if the default limit for retrieving news is 5, this should be reflected in all system prompts and documentation to avoid confusion. In short, do not assume any default parameter, if you think something should have a default value, include it either in the system prompt or function field description or as default field in the parameter. 3. Pick a clear scenario: The role of the user talking with the AI assistant must be clear. They could be an end-user (such as a guest renting a hotel room through the system), a manager, part of a staff of an establishment, etc. The functions that are included must take the role of the user into account: if the user is an end-user in a booking system, you MUST NOT include functions that perform operations that the user wouldn't reasonably be able to perform, like cancelling other user's bookings. Consistent naming standards : Functions are commonly named with a verb and a noun, such as get_reservations , createUser , get_compliance , add task , etc. This standard isn't mandatory, but should be followed if you don't have a good reason not to. You should also pick one \"case\" and stick with it: PascalCase, camelCase, snake_case, etc. in order to have a consistency for the system having the functionalities.","title":"Best Practices"},{"location":"best-practices/#best-practices","text":"","title":"Best Practices"},{"location":"best-practices/#1enum","text":"Try to use either enum s or options mentioned in descriptions as much as possible.","title":"1.Enum:"},{"location":"best-practices/#2-function-descriptions","text":"Always include the function description within the function definition for consistency.","title":"2. Function descriptions:"},{"location":"best-practices/#parameters","text":"Clear parameter definitions : Specify whether parameters like max_length refer to the number of characters, words, or sentences. This prevents ambiguity and ensures that users of the function have a clear understanding of how to use it effectively. Consistent default parameters : Ensure that default parameter values are consistent across different parts of the system. For example, if the default limit for retrieving news is 5, this should be reflected in all system prompts and documentation to avoid confusion. In short, do not assume any default parameter, if you think something should have a default value, include it either in the system prompt or function field description or as default field in the parameter.","title":"Parameters"},{"location":"best-practices/#3-pick-a-clear-scenario","text":"The role of the user talking with the AI assistant must be clear. They could be an end-user (such as a guest renting a hotel room through the system), a manager, part of a staff of an establishment, etc. The functions that are included must take the role of the user into account: if the user is an end-user in a booking system, you MUST NOT include functions that perform operations that the user wouldn't reasonably be able to perform, like cancelling other user's bookings. Consistent naming standards : Functions are commonly named with a verb and a noun, such as get_reservations , createUser , get_compliance , add task , etc. This standard isn't mandatory, but should be followed if you don't have a good reason not to. You should also pick one \"case\" and stick with it: PascalCase, camelCase, snake_case, etc. in order to have a consistency for the system having the functionalities.","title":"3. Pick a clear scenario:"},{"location":"function-call/","text":"Function Call A function call is a suggestion call by the model to the system using the LLM by an API to be performed. 1. Single function call In a single function call; the user prompts such a query that requires exactly one function to be called. \"What is the weather like in Tokyo?\" 2. Multiple parallel function calls In a multiple parallel function calls; the user prompts such a query that requires more than one function to e called. \"What is the weather like in Tokyo and Paris?\" 3. Multiple consecutive function calls In a multiple consecutive function calls; the user prompts such a query that requires consecutive functions to be called; because the second function call would depend on the first one's output. \"Create an appointment for XYZ on day A or B.\" (First we need to check the availability of XYZ on day A and B to do so.) 4. No function call In a no function call; the user prompts such a query that does not require a function to be called. The reason might be either because of a unsupported actions, or a query that might not require a function call at all. \"What are the signs of the rain?\"","title":"Function Call"},{"location":"function-call/#function-call","text":"A function call is a suggestion call by the model to the system using the LLM by an API to be performed.","title":"Function Call"},{"location":"function-call/#1-single-function-call","text":"In a single function call; the user prompts such a query that requires exactly one function to be called. \"What is the weather like in Tokyo?\"","title":"1. Single function call"},{"location":"function-call/#2-multiple-parallel-function-calls","text":"In a multiple parallel function calls; the user prompts such a query that requires more than one function to e called. \"What is the weather like in Tokyo and Paris?\"","title":"2. Multiple parallel function calls"},{"location":"function-call/#3-multiple-consecutive-function-calls","text":"In a multiple consecutive function calls; the user prompts such a query that requires consecutive functions to be called; because the second function call would depend on the first one's output. \"Create an appointment for XYZ on day A or B.\" (First we need to check the availability of XYZ on day A and B to do so.)","title":"3. Multiple consecutive function calls"},{"location":"function-call/#4-no-function-call","text":"In a no function call; the user prompts such a query that does not require a function to be called. The reason might be either because of a unsupported actions, or a query that might not require a function call at all. \"What are the signs of the rain?\"","title":"4. No function call"},{"location":"function-pivoting-aka-tool-search/","text":"Function Pivoting aka Tool Search 1. Pivoting a function JSON Schema pivoting is a way that there is a one Tool Search function which will search withing the tools and output the most relevant one so that the model can use that outputted function in next call. Benefit: Picking the right function will be under your control instead of LLMs. When there are too many functions; becuase you don't need to send them all, it will save a significant amount of tokens which will reduce the cost. Drawback: It causes at least 2 function calls in each case, so there will always be a delay. Moreover, it might not be that right to leave the decision of the functions to your app. LLMs are obviously better to choose the correct function with correct parameters. Lastly, many LLMs are not trained in that way, this would be just an experiment.","title":"Function Pivoting aka Tool Search"},{"location":"function-pivoting-aka-tool-search/#function-pivoting-aka-tool-search","text":"","title":"Function Pivoting aka Tool Search"},{"location":"function-pivoting-aka-tool-search/#1-pivoting-a-function","text":"JSON Schema pivoting is a way that there is a one Tool Search function which will search withing the tools and output the most relevant one so that the model can use that outputted function in next call.","title":"1. Pivoting a function"},{"location":"function-pivoting-aka-tool-search/#benefit","text":"Picking the right function will be under your control instead of LLMs. When there are too many functions; becuase you don't need to send them all, it will save a significant amount of tokens which will reduce the cost.","title":"Benefit:"},{"location":"function-pivoting-aka-tool-search/#drawback","text":"It causes at least 2 function calls in each case, so there will always be a delay. Moreover, it might not be that right to leave the decision of the functions to your app. LLMs are obviously better to choose the correct function with correct parameters. Lastly, many LLMs are not trained in that way, this would be just an experiment.","title":"Drawback:"},{"location":"recommendations-for-improvement/","text":"Recommendations for Improvement Parameter documentation: Enhance function signatures with explicit parameter documentation, including the type, purpose, and any default values. Error handling: In order to LLM to handle an error occurred after a bad call, it's a good practice to include how to handle certain type of errors in descriptions of either functions or parameters.","title":"Recommendations for Improvement"},{"location":"recommendations-for-improvement/#recommendations-for-improvement","text":"","title":"Recommendations for Improvement"},{"location":"recommendations-for-improvement/#parameter-documentation","text":"Enhance function signatures with explicit parameter documentation, including the type, purpose, and any default values.","title":"Parameter documentation:"},{"location":"recommendations-for-improvement/#error-handling","text":"In order to LLM to handle an error occurred after a bad call, it's a good practice to include how to handle certain type of errors in descriptions of either functions or parameters.","title":"Error handling:"},{"location":"turn/","text":"Turn Turn is basically a move for a role. 1. Single turn In a single turn conversation, the user acts or prompts; then the model answers and the user does not continue the conversation. 2. Multiple turns In a multiple turns conversation, the user acts or prompts; then the model answers and the user goes on with follow-up prompts. There should be at least 2 user prompts which includes assistant responses in between.","title":"Turn"},{"location":"turn/#turn","text":"Turn is basically a move for a role.","title":"Turn"},{"location":"turn/#1-single-turn","text":"In a single turn conversation, the user acts or prompts; then the model answers and the user does not continue the conversation.","title":"1. Single turn"},{"location":"turn/#2-multiple-turns","text":"In a multiple turns conversation, the user acts or prompts; then the model answers and the user goes on with follow-up prompts. There should be at least 2 user prompts which includes assistant responses in between.","title":"2. Multiple turns"},{"location":"variants/","text":"Variants From an original task, 4-5 variants might be created. To create variants: Variant with system instructions: Slightly change the system prompt with a variant scenario. Behavioral: Include different kind of behavior e.g. assistant should be concise, assistant should be kind etc Data related: Change a data value such as date, name, email, phone etc. Variant with user persona: Use exactly same schema and system prompt but change the user behavior. Users might have different personas e.g. user might not provide all the informations or they might provide all at once Variant with json schema: Slightly change the JSON schema while keepin the res as same. Update json schema with competing or mixed functions (Say if original includes 3 functions, this might include 5-6 functions) Variant with adversarial cases: Unhappy cases, where the assistant might not able to fulfill the request at once, or might give up or might fail nicely, recover from failure etc. Variant with noisy user prompt: Users sometimes might ask same thing but with different wording and/or with a noisy data Some users might be toxic Some users might use slang Some developers might include user prompt in JSON/HTML format Some users might be verbose Some users might use some shortcuts e.g. \"properties.color = red\" , instead of saying \"give me red products\"","title":"Variants"},{"location":"variants/#variants","text":"From an original task, 4-5 variants might be created.","title":"Variants"},{"location":"variants/#to-create-variants","text":"","title":"To create variants:"},{"location":"variants/#variant-with-system-instructions","text":"Slightly change the system prompt with a variant scenario. Behavioral: Include different kind of behavior e.g. assistant should be concise, assistant should be kind etc Data related: Change a data value such as date, name, email, phone etc.","title":"Variant with system instructions:"},{"location":"variants/#variant-with-user-persona","text":"Use exactly same schema and system prompt but change the user behavior. Users might have different personas e.g. user might not provide all the informations or they might provide all at once","title":"Variant with user persona:"},{"location":"variants/#variant-with-json-schema","text":"Slightly change the JSON schema while keepin the res as same. Update json schema with competing or mixed functions (Say if original includes 3 functions, this might include 5-6 functions)","title":"Variant with json schema:"},{"location":"variants/#variant-with-adversarial-cases","text":"Unhappy cases, where the assistant might not able to fulfill the request at once, or might give up or might fail nicely, recover from failure etc.","title":"Variant with adversarial cases:"},{"location":"variants/#variant-with-noisy-user-prompt","text":"Users sometimes might ask same thing but with different wording and/or with a noisy data Some users might be toxic Some users might use slang Some developers might include user prompt in JSON/HTML format Some users might be verbose Some users might use some shortcuts e.g. \"properties.color = red\" , instead of saying \"give me red products\"","title":"Variant with noisy user prompt:"}]}